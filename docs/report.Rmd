---
title: "AMP for SLOPE"
author: "Bart≈Çomiej Polaczyk"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  # pdf_document
  html_document:
   css: AMP-SLOPE.css
   mathjax: local
   self_contained: false
abstract: |
  The aim of this project is to investigate the the approximate message passing algorithm for SLOPE regularization problem based on [@bu2019algorithmic] and compare it with classical convex optimization methods.
  Some numerical experiments regarding the cases that do not fit into the theoretical framework of [@bu2019algorithmic] are also performed and analyzed.
bibliography: AMP-SLOPE.bib
header-includes:
  - \usepackage{amsmath,mathtools}
  - \usepackage[ruled,vlined]{algorithm2e}
---
%LaTeX commands
\newcommand{\R}{\mathbb{R}}
\newcommand{\E}{\mathbb{E}}

%numbering equations in html format
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Libraries
packages <- c("foreign", "lubridate", "ggplot2","reshape2")
lapply(packages, library, character.only = TRUE)

# working directory
#setwd("~/Dropbox/Uczelnia//")
```


# Theoretical bacground
## Introduction
We are interested in solving the standard linear inverse problem
\begin{equation}\label{eq:LM-problem} 
  y = Ax + w,
\end{equation} 
where $y\in \R^n$ and $A\in\R^{n\times p}$ are known parameters of the model, $w\in\R^n$ is a random noise vector and $x\in\R^p$ is an unknown vector of paramteres we wish to estimate.
We assume $p\gg n$, i.e. the number of features is much greater than the size of the sample data and whence there might be many potential solutions to the problem$~\eqref{eq:LM-problem}$.

To resolve this issue and prevent overfitting, we introduce a penalty function $\phi$ which faforizes sparse solutions of$~\eqref{eq:LM-problem}$, i.e. now we are looking among the minimizers of the following form
\begin{equation}\label{eq:SLOPE}
  \widehat{x} = \operatorname*{argmin}_x \{\, \frac{1}{2}\Vert Ax - y \Vert_2^2 + \phi(x) \,\}.
\end{equation}
The usual choices of $\phi$ are scaled $l^2$ penalty (Tikhonov regularization) and $l^1$ penalty (LASSO).
This note concerns SLOPE regularization, introduced for the first time in [@MR3418717], which assumes $\phi$ to be the sorted $l^1$ penalty, i.e.
$$
  \phi(x)= \phi_{\theta}(x) = \sum_{i=1}^n \theta_ix_i^{\downarrow},
$$
where $x_1^\downarrow \ge x_2^\downarrow \ge \ldots \ge x_n^\downarrow$ is the ordered permutation of the vector $(\vert x_1\vert,\vert x_2\vert,\ldots,\vert x_n\vert)$ and $\theta_1 \ge \theta_2 \ge \ldots \theta_p$ are hyperparameters of the model.
Such a choice is a generalization of the $l^1$ regularization, as can be seen by taking $\theta_i=\operatorname{const}$.

The fact that $\phi_\theta$ is non-separable makes the analysis of its teoretical properties much more onerous than in case of classical (separable) models, cf. [@MR3418717, @bu2019algorithmic].
Nonetheless, it turns out that SLOPE has two advantages over other regularization methods such as LASSO and knocoffs, namely:

1. it achieves certain minimax estimation properties under particular random designs *without* requiring any knowledge of the sparsity degree of $\widehat{x}$, cf. [@MR3852663];
2. it controls the false discovery rate in the case of independent predictors, cf. [@MR3418717].

We are interested in the algorithmic solutions to the problem $\eqref{eq:SLOPE}$.
Since the objective function in $\eqref{eq:SLOPE}$ is convex but not smooth, one can not apply directly the classical gradient descent and has to turn to other methods.

A natural alternative solution is the plethora of proximal algorithms, e.g. ISTA (and its improvement -- FISTA, cf. [@MR2486527]) or more classical alternating direction methods of multipliers (ADMM).
The methods have been throughly studied in the literature, cf. [@MR3719240] for a detailed treatment of the subject.

In this note we will focus on another approach, via the approximate message passing, considered for the first time in context of the LASSO problem in [@donoho2009message] and subsequentially developed in e.g. [@MR2810285], and for the SLOPE regularization in [@bu2019algorithmic] -- see e.g. [@zdeborova2016statistical] for an accessible derivation of the method.

In the subsequent sections we will describre briefly some of these approaches.

## Proximal methods

Denoting $g(x)=\frac{1}{2}\Vert Ax - y \Vert_2^2$, the ISTA iteration can be written as:

******
**ISTA:**<br>
Initialize $x\in\R^p$, $\gamma\in\R_+$<br>
**while** (*stopping condition*) **{**<br>
&emsp;  $x = \operatorname{prox}_{\gamma \phi}\big(x - \nabla g(x)\big)$;<br>
&emsp;  *update*($\gamma$);<br>
**} return** $x$

******

where $\gamma$ is the learning rate, *update* is an appropriate backtracking procedure and $\operatorname{prox}$ denotes the proximal operator given by
$$
  \operatorname{prox}_{\gamma\phi}(y) := \operatorname*{argmin}_x \{\, \gamma\phi(x) + \frac{1}{2}\Vert x-y \Vert_2^2 \,\}.
$$

@MR2486527 have introduced a faster version of ISTA, a.k.a. FISTA, which is based on the idea of Nesterov momentum.
The general form of the algorithm is the following:

******
**FISTA:**<br>
Initialize $x=y\in\R$, $\gamma \in \R_+$, $t = 1$<br>
**while** *(stopping condition)* **{**<br>
&emsp;  $x_{old}=x$;<br>
&emsp;  $x = \operatorname{prox}_{\gamma \phi}\big(y - \nabla g(y)\big)$<br>
&emsp;  $y = x_{old} + t(x-x_{old})$<br>
&emsp;  *update*($\gamma, t$);<br>
**} return** $x$

******

Here $t$ can be thought of as a momentum term, which (if updated correctly) can increase substantialy the speed of convergence of the algorithm.
Note that keeping $t=1$ results in ISTA algorithm.

One of the difficulties in dealing with SLOPE is that the regulizer $\phi$ is non-separable and thus its proximal operator cannot be applied element-wise.
Following [@MR3418717], it can be easily checked that...


## Approximate message passing


# Numerical experiments


## References
